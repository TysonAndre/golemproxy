package distribution

type ModulaContinuum struct {
	modulaIndexes []int
}

func NewModula(buckets []Bucket) (*ModulaContinuum, error) {

	numbuckets := len(buckets)

	if numbuckets == 0 {
		// let them error when they try to use it
		return nil, nil
	}

	totalweight := 0
	for _, b := range buckets {
		totalweight += b.Weight
	}

	modulaIndexes := make([]int, 0, totalweight)

	for _, b := range buckets {
		for k := 0; k < b.Weight; k++ {
			modulaIndexes = append(modulaIndexes, b.Data)
		}
	}

	return &ModulaContinuum{
		modulaIndexes: modulaIndexes,
	}, nil
}

// Retrieves the array index for a uint32 value generated by another algorithm.
func (c ModulaContinuum) Get(h uint32) int {
	if len(c.modulaIndexes) == 0 {
		panic("Expected ring to be non-empty")
	}

	return c.modulaIndexes[h%uint32(len(c.modulaIndexes))]
}
