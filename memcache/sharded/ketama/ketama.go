// Package ketama implements consistent hashing compatible with twemproxy (hopefully)
/*
This implementation draws from the Daisuke Maki's Perl module, which itself is
based on the original libketama code.  That code was licensed under the GPLv2,
and thus so is this.

The major API change from libketama is that Algorithm::ConsistentHash::Ketama allows hashing
arbitrary strings, instead of just memcached server IP addresses.

Original source: https://github.com/dgryski/go-ketama/blob/master/ketama.go
*/
package ketama

import (
	"crypto/md5"
	"fmt"
	"sort"
)

type Bucket struct {
	Label  string
	Weight int
	// Index of the client to use
	Data int
}

type continuumPoint struct {
	bucket Bucket
	point  uint32
}

type Continuum struct {
	ring points
}

type points []continuumPoint

func (c points) Less(i, j int) bool { return c[i].point < c[j].point }
func (c points) Len() int           { return len(c) }
func (c points) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }

func md5Digest(in string) []byte {
	h := md5.New()
	h.Write([]byte(in))
	return h.Sum(nil)
}

func NewKetama(buckets []Bucket) (*Continuum, error) {

	numbuckets := len(buckets)

	if numbuckets == 0 {
		// let them error when they try to use it
		return nil, nil
	}

	ring := make(points, 0, numbuckets*160)

	totalweight := 0
	for _, b := range buckets {
		totalweight += b.Weight
	}

	for i, b := range buckets {
		pct := float32(b.Weight) / float32(totalweight)

		// this is the equivalent of C's promotion rules, but in Go, to maintain exact compatibility with the C library
		limit := int(float32(float64(pct) * 40.0 * float64(numbuckets)))

		for k := 0; k < limit; k++ {
			/* 40 hashes, 4 numbers per hash = 160 points per bucket */
			ss := fmt.Sprintf("%s-%d", b.Label, k)
			digest := md5Digest(ss)

			for h := 0; h < 4; h++ {
				point := continuumPoint{
					point:  uint32(digest[3+h*4])<<24 | uint32(digest[2+h*4])<<16 | uint32(digest[1+h*4])<<8 | uint32(digest[h*4]),
					bucket: buckets[i],
				}
				ring = append(ring, point)
			}
		}
	}

	sort.Sort(ring)

	return &Continuum{
		ring: ring,
	}, nil
}

// Retrieves the Data for a uint32 value generated by another algorithm.
func (c Continuum) Get(h uint32) int {
	if len(c.ring) == 0 {
		panic("Expected ring to be non-empty")
	}

	// the above md5 is way more expensive than this branch
	var i uint
	i = uint(sort.Search(len(c.ring), func(i int) bool { return c.ring[i].point >= h }))
	if i >= uint(len(c.ring)) {
		i = 0
	}

	return c.ring[i].bucket.Data
}
